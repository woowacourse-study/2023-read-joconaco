# 2.3 코드의 계층

이 챕터에선 함수, 클래스, 인터페이스를 통해 코드를 추상화 계층으로 나누기 위한 최상의 방법을 살펴본다.

## 2.3.1 API 및 구현 세부 사항

### `API`란? 응용 프로그램 사이에서 데이터를 주고받는 방법 즉, 프로그램 끼리 연결 해주는 중간다리 이다.

- 코드를 작성할때 고려해야할 두가지 측면
    - 호출할때 볼 수 있는 내용
        - public 클래스, 인터페이스 및 함수
        - 이름, 입력 매개변수 및 반환 유형이 표현하고자 하는 개념
        - 코드 호출 시 올바르게 사용하기 위해 알아야 하는 추가 정보(예: 호출 순서)

    - 호출할때 볼 수 없는 내용
        - 구현 세부 사항

### 다음은 그림은 클래스를 공개 API, 구현 세부사항으로 나누는 예시를 보여준다.
    /////그림//////

즉, 호출하는 쪽에서 코드에 대해 알고있는 사항을 `공개API`,

API로 공개되지 않은 내용은 `구현 세부 사항`이라 할 수 있다.

#### 코드의 일부를 작성하거나 수정할때 API에 수정 사항에 대한 구현 세부 정보가 새어나간다면

#### 추상화 계층이 명확하게 구분된 것이 아니다.

## 2.3.2 함수

### `함수` 는 하나의 잘 써진 문장처럼 읽히는 것이 이상적이다.

다음은 하나의 `함수` 가 많은 역할을 시행해 코드를 이해하기 어렵다

```
public List<String> splitString(String names) {
    //입력 패턴과 일치하는지 검사
    Matcher matcher = INPUT_NAMES_PATTERN.matcher(names);
    if (!matcher.matches()) {
    throw new IllegalArgumentException("입력된 플레이어들의 이름 형식이 올바르지 않습니다.");
    }
    // string을 , 기준으로 분리
    List<String> splitNames = Arrays.stream(names.split(","))
                    .collect(Collectors.toUnmodifiableList());
    return splitNames;
}
```

위 함수를 한문장으로 표현하면 '패턴 검사(패턴과 일치하지 않으면 예외처리한다.) 하고, 검증이 되면, 문자를 분리하라.' 가 될것이다.

이를 '패턴 검사 후 문자를 분리하라' 라는 문장으로 표현할 수 있는 함수라면 훨씬 좋을것이다.

- 단일 업무 수행
- 잘 명명된 다른 함수를 호출해서 더 복잡한 동작 구성
- tip! -> 작성한 함수를 문장으로 만들어 보고 어렵거나 어색하면 더 작은 함수로 나눈다.

```
public List<String> splitString(String names) {
        validateNamesInputForm(names);
        List<String> splitNames = Arrays.stream(names.split(","))
                    .collect(Collectors.toUnmodifiableList());
        return splitNames;
}

private void validateNamesInputForm(String names) {
        Matcher matcher = INPUT_NAMES_PATTERN.matcher(names);
        if (!matcher.matches()) {
                throw new IllegalArgumentException("입력된 플레이어들의 이름 형식이 올바르지 않습니다.");
        }
}
```

### 위에 예제처럼 함수의 역할을 분리 할 경우 장점

- `가독성` 이 좋아진다.
    - splitString() 를 '패턴을 검사하고, 검증이되면, 문자를 분리한다' 로 표현할 수 있다.
- `재사용` 할 수 있는 코드가 된다.
    - 다른 코드에서 패턴을 검사할 일이 생긴다면 validateNamesInputForm() 함수를 사용할 수 있다.

## 2.3.3 클래스

### 클래스 설계시 법칙

- `줄 수`: 300줄을 넘기지 않기
    - 클래스 안에 내용이 너무 많아지면 적절한 크기가 아님을 경고한다.

- `응집력`
    - `순차적 응집력`: ex) 커피만들기 -> 원두를 먼저 갈고 추출 한다. -> 갈기, 추출 사이에 서로 응집력이 있다.
    - `기능적 응집력`: 하나의 일을 하기 위해 몇가지 요소들이 기여하는 데에 발생한다.

- `관심사의 분리`: 각각 다른 문제를 다루는 개별 구성 요소로 분리되어야 한다.

### 클래스를 잘 분리했을 시 네가지 핵심요소

- `코드 가독성`
- `코드 모듈화`: 기능을 독립적인 부품으로 분리한다.
- `코드 재사용성 및 일반화`
- `테스트 용이성 및 적절한 테스트`

### 안좋은 클래스의 예시
```
class TextSummarizer{
    String summerizeText(){
        return splitIntoParagraphs(text)
            .filter(paragraph -> calculateImportance(paragraph))
            .join("\n")
    }
    
    private splitIntoParagraphs(){
      return a.split();
    }
    private List<String> split(){}
    
    private calculateImportance(){
      String a= detect();
      ...
    }
    private String detect(){}
}
```
위 클래스는 단락 분할, 중요도 계산 두가지 역할을 한다.

하지만 누군가는 텍스트 요약하는 한가지 일에만 관련이 있는 클래스 라고 주장할 수 있다.

이럴때 위에서 언급한 핵심 요소를 생각해 보자.

- 함수가 너무 많으면 파악하는 데 시간이 오래걸린다.
- 코드가 모듈화 되어있지 않아 성능 개선을 할때 코드 재구성이 어렵게 된다.
- 코드를 재사용 할 수 없다.
    - splitIntoParagraphs() 함수를 다른 클래스에서 필요할때 재사용이 불가능하다.
    - public으로 바꾸게 되면 클래스 명이 api에 노출되게 된다.
- 테스트가 어려워 진다.

```
class TextSummarizer{
    private final ParagraphFinder paragraphFinder;
    private final TextImportance textImportance;
    
    //의존성 주입
    TextSummarizer(ParagraphFinder paragraphFinder,
                   TextImportance textImportance){
        this.paragraphFinder = paragraphFinder;
        this.textImportance = textImportance;
    }
    
    String summerizeText(String text){
        return paragraphFinder.find(text)
            .filter(paragraph -> textImportance.isImportance(paragraph))
            .join("\n")
    }
}

class ParagraphFinder{
    List<String> find (){};
    
    private calculateImportance(){
        String a= detect();
        ...
    }
    private String detect(){}
}

class TextImportance{
    boolean isImportance(){}
    
    private calculateImportance(){
        String a= detect();
        ...
    }
    private String detect(){}
}
```
문단을 찾는 ParagraphFinder, 중요도를 계산하는 TextImportance 의 역할을 클래스로 나눠

TextSummarizer 에 의존성 주입을 하였다.

이로써 TextSummarizer 클래스를 몇 초 만에

- 단락을 찾는다.
- 중요하지 않은 것은 걸러낸다.
- 남아 있는 단락을 연결한다.

를 알게 된다.

점수계산은 관심 없지만 단락을 어떻게 찾았는지 궁금하면 ParagraphFinder 클래스로 이동하면 된다.

### 필자의 요약

위에 예시는 역할 분리가 눈에 보이지만 애매한 경우도 많다.

그럴 경우 위에 네가지 요소

`클래스의 역할을 파악하는데 시간이 오래 걸리는지`

`성능을 개선할 때 코드의 재구성이 곤란해 지는지`

`확장성을 고려했을때 적절한 클래스 인지`

`중요한 함수들이 private 이어서 테스트가 곤란할때 클래스에 역할이 잘 분배되었는지`

를 고려해 보자.
