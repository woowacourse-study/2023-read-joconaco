## 6.6 미래를 대비한 열거형 처리
6.6에서는 ‘우리가 의존하는 코드에 대해 부실한 가정을 할 경우에도 우리의 예상을 벗어나는 결과를 초래할 수 있다’ 를 알려주며 예를 보여준다.

**열거형에 대한 논쟁**

- 형 안전성을 제공하고 함수, 시스템 유효하지 않은 입력을 방지하는 훌륭하고 간단한 방법이라는 주장
- 열거형의 특정 값을 처리하기 위한 논리가 코드 전반에 퍼져있어서 간결한 추상화 계층을 막는 주장

**열거형을 접하거나 다뤄야 할 가능성**

- 다른 사람 코드의 결과를 사용해야하며, 그들이 열거형을 즐겨 사용할 수 있다.
- 다른 시스템에서 제공하는 결과를 사용할 때 열거형은 유일한 실용적 데이터 형식일 수 있다.

열거형에 더 많은 값이 추가될 수 있다는 예상을 하고, 코드를 작성하라. 무시한다면 좋지 않은 결과를 초래할 수 있다.

## 6.6.1 미래에 추가될 수 있는 열거값을 암묵적으로 처리하는 것은 문제가 될 수 있다.

열거형 내 값을 보고 if문을 사용해서 처리한다면 현재는 문제가 없지만, 다른 값이 추가될 경우에는 문제가 될 수 있다.

```java
enum Status{
	START,
	END;
}

Boolean isStatus(Status status){
	if(status == Status.START)
		return false;
	return true
}
```

이런 상황에서 `Status`에 새로운 결과인 `Ready`가 추가되었다고 생각해보자.

`enum` 타입은 열거형 정의에서 멀리 떨어져 있을 수 있는데, `Status`가 수정됨에따라 `isStatus`가 당연히 수정될 것 이라고 가정하는 것은 위험하다.

`isStatus()` 함수 작성자는 후에 열거형 값이 더 추가될 수 있다는 사실을 무시했다. 코드는 불안정하고 **신뢰할 수 없는 가정**에 기초해 작성되었고 파국적인 결과를 초래한다.
